## 问题

1.当启动时 马上进行回流 此时哨兵将master切换成slave 将导致此次回流失效 （如果此时回流正在进行中的话 将会带来不必要的资源浪费)

## 方案

1. 只对故障重启后回流或者双向同步进行延迟（可被人工peerof命令重置掉延迟,也可以指定peerof延迟）
   1. 优点:只针对特定场景进行延迟, 灵活性高 (单个peerof连接力度的)
   2. 缺点:引入新机制

## 具体实现

1. 如何判断故障重启
   1. 根据local-clock是否大于-1 表示是故障重启
   2. 如何确保启动后local-clock 在启动后不为-1?
      1. local-clock初始化时 -1
      2. 加载config 后修改
      3. 启动完成后 如果依然是-1时 设置成0 且写入到config
      4. 每5秒从内存刷新一次到config内
2. 如何实现延迟peerof
   1. restart-lazy-peerof-time （ms为单位）
   2. 故障重启后 从config或者rdb中加载获得的peer信息中增加time（当前时间 + 延迟时间)
   3. 定时器创建peer连接时, 需要在peer信息time之后才能创建
   4. 用peerof命令重新设置的时候 会清空掉time



其他问题:

1. 当前有 master(m1)和slave(s1) 当 m1挂了 s1成为master 后 m1重启后（未满足回流的时 依然可写) 哨兵还没切换s1 但是用户配置还未更新 依然后数据写入到m1 直到哨兵切换m1成为slave期间写入的数据 都将会丢失
   1. 我认为 此场景普通redis 依然存在. 且并不能通过延迟顺便解决的
   2. 和普通redis统一方式，保证docker重启后redis进程不会自动启动