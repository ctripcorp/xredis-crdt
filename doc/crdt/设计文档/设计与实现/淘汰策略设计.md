# 设计与实现

## 淘汰策略的修改

设计说明:

1. redis本身存在内存淘汰机制.但是由于引入gc机制 从用户角度来看 优先淘汰tombstone内存较为合理

相关说明:

1. 无法完全保证数据的最终一致性
   1. 当触发淘汰策略时,我们认为是再可用性和一致性上作出抉择  我们选中了可用性

具体的实现步骤:

1. 发现内存不足时且淘汰策略不是noeviction时,优先淘汰tombstone内的数据

2. 先每个db选取5个tombstone （tombstone 先尝试gc 如果被gc的话重新选tombstone)

3. 计算分数进行排序 （分数小的优先删除 ）  

   1. VC越接近当前进程VC的分数越高  
   2. 本地的VC分数会比其他机房分数高

4. 剔除tombstone同步给slave  不同步给peer

   （新增命令CRDT.enforceGc key)

   1. 尽量master和slave避免数据不一致 
   2. 如果通知其他peer gc key的话  会让受影响的分片更多。
   3. 如果slave内存不足 释放的tombstone的话 不会往下传的  所以master和slave是存在不一致的情况的

5. 剔除tombstone操作增加统计和日志（方便排查问题和数据恢复）  后续添加到hickwall

会出现的场景:

所有场景都是A,B,C机房互通  D机房隔离

1.没有冲突情况下的删除tombstone（删除本机房)

|      | A               | B      | C      | D            |
| :--- | :-------------- | :----- | :----- | :----------- |
|      | k=>1            | k=>1   | k=>1   | k=>1（隔离） |
| t1   | del k           |        |        |              |
| t2   | 删除k tombstone |        |        |              |
| t3   |                 |        |        | 恢复         |
|      | k=>nil          | k=>nil | k=>nil | k=>1         |

人工修复: 查看日志  查看剔除的tombstone的k   然后删除D节点k

2.没有有冲突情况下的删除tombstone（删除其他机房的tombstone)

|      | A               | B      | C      | D            |
| :--- | :-------------- | :----- | :----- | :----------- |
|      | k=>1            | k=>1   | k=>1   | k=>1（隔离） |
| t1   |                 | del k  |        |              |
| t2   | 删除k tombstone |        |        |              |
| t3   |                 |        |        | 恢复         |
|      | k=>nil          | k=>nil | k=>nil | k=>nil       |

3.有冲突情况下的删除tombstone（删除本机房的tombstone)

|      | A               | B          | C      | D            |
| :--- | :-------------- | :--------- | :----- | :----------- |
|      | k=>1            | k=>1       | k=>1   | k=>1（隔离） |
| t1   |                 | set k => 2 |        |              |
| t2   | del k           |            |        |              |
| t3   | 删除k tombstone |            |        |              |
|      | sync            |            |        |              |
|      | k=>2            | k=>nil     | k=>nil | k=>1         |

人工修复: 保证数据一致性  选择恢复k = 2 或者删除k

4.有冲突情况下的删除tombstone（删除其他机房的tombstone)

|      | A               | B      | C          | D            |
| :--- | :-------------- | :----- | :--------- | :----------- |
|      | k=>1            | k=>1   | k=>1       | k=>1（隔离） |
| t1   |                 |        | set k => 2 |              |
| t2   |                 | del k  |            |              |
|      | 先收到del k     |        |            |              |
|      | 删除k tombstone |        |            |              |
|      | 收到set k 2     |        |            |              |
|      | sync            |        |            |              |
|      | k=>2            | k=>nil | k=>nil     | k=>1         |

人工修复: 保证数据一致性  选择恢复k = 2 或者删除k